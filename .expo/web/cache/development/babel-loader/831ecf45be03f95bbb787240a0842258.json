{"ast":null,"code":"'use strict';\n\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/finnbeardmore/Documents/GitHub/ITCrowd/node_modules/react-native-view-transformer/library/transform/ViewTransformer.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport ReactNative from \"react-native-web/dist/index\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport PropTypes from 'prop-types';\nimport { createResponder } from 'react-native-gesture-responder';\nimport Scroller from 'react-native-scroller';\nimport { Rect, Transform, transformedRect, availableTranslateSpace, fitCenterRect, alignedRect, getTransform } from \"./TransformUtils\";\n\nvar ViewTransformer = function (_Component) {\n  _inherits(ViewTransformer, _Component);\n\n  var _super = _createSuper(ViewTransformer);\n\n  function ViewTransformer(props) {\n    var _this;\n\n    _classCallCheck(this, ViewTransformer);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      scale: 1,\n      translateX: 0,\n      translateY: 0,\n      animator: new Animated.Value(0),\n      width: 0,\n      height: 0,\n      pageX: 0,\n      pageY: 0\n    };\n    _this._viewPortRect = new Rect();\n    _this.cancelAnimation = _this.cancelAnimation.bind(_assertThisInitialized(_this));\n    _this.contentRect = _this.contentRect.bind(_assertThisInitialized(_this));\n    _this.transformedContentRect = _this.transformedContentRect.bind(_assertThisInitialized(_this));\n    _this.animate = _this.animate.bind(_assertThisInitialized(_this));\n    _this.scroller = new Scroller(true, function (dx, dy, scroller) {\n      if (dx === 0 && dy === 0 && scroller.isFinished()) {\n        _this.animateBounce();\n\n        return;\n      }\n\n      _this.updateTransform({\n        translateX: _this.state.translateX + dx / _this.state.scale,\n        translateY: _this.state.translateY + dy / _this.state.scale\n      });\n    });\n    return _this;\n  }\n\n  _createClass(ViewTransformer, [{\n    key: \"viewPortRect\",\n    value: function viewPortRect() {\n      this._viewPortRect.set(0, 0, this.state.width, this.state.height);\n\n      return this._viewPortRect;\n    }\n  }, {\n    key: \"contentRect\",\n    value: function contentRect() {\n      var rect = this.viewPortRect().copy();\n\n      if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n        rect = fitCenterRect(this.props.contentAspectRatio, rect);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"transformedContentRect\",\n    value: function transformedContentRect() {\n      var rect = transformedRect(this.viewPortRect(), this.currentTransform());\n\n      if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n        rect = fitCenterRect(this.props.contentAspectRatio, rect);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"currentTransform\",\n    value: function currentTransform() {\n      return new Transform(this.state.scale, this.state.translateX, this.state.translateY);\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _this2 = this;\n\n      this.gestureResponder = createResponder({\n        onStartShouldSetResponder: function onStartShouldSetResponder(evt, gestureState) {\n          return true;\n        },\n        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(evt, gestureState) {\n          return true;\n        },\n        onResponderMove: this.onResponderMove.bind(this),\n        onResponderGrant: this.onResponderGrant.bind(this),\n        onResponderRelease: this.onResponderRelease.bind(this),\n        onResponderTerminate: this.onResponderRelease.bind(this),\n        onResponderTerminationRequest: function onResponderTerminationRequest(evt, gestureState) {\n          return false;\n        },\n        onResponderSingleTapConfirmed: function onResponderSingleTapConfirmed(evt, gestureState) {\n          _this2.props.onSingleTapConfirmed && _this2.props.onSingleTapConfirmed();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      this.props.onViewTransformed && this.props.onViewTransformed({\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      });\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelAnimation();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var gestureResponder = this.gestureResponder;\n\n      if (!this.props.enableTransform) {\n        gestureResponder = {};\n      }\n\n      return React.createElement(View, _extends({}, this.props, gestureResponder, {\n        ref: 'innerViewRef',\n        onLayout: this.onLayout.bind(this),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 7\n        }\n      }), React.createElement(View, {\n        style: {\n          flex: 1,\n          transform: [{\n            scale: this.state.scale\n          }, {\n            translateX: this.state.translateX\n          }, {\n            translateY: this.state.translateY\n          }]\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 131,\n          columnNumber: 9\n        }\n      }, this.props.children));\n    }\n  }, {\n    key: \"onLayout\",\n    value: function onLayout(e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          width = _e$nativeEvent$layout.width,\n          height = _e$nativeEvent$layout.height;\n\n      if (width !== this.state.width || height !== this.state.height) {\n        this.setState({\n          width: width,\n          height: height\n        });\n      }\n\n      this.measureLayout();\n      this.props.onLayout && this.props.onLayout(e);\n    }\n  }, {\n    key: \"measureLayout\",\n    value: function measureLayout() {\n      var _this3 = this;\n\n      var handle = ReactNative.findNodeHandle(this.refs['innerViewRef']);\n      NativeModules.UIManager.measure(handle, function (x, y, width, height, pageX, pageY) {\n        if (typeof pageX === 'number' && typeof pageY === 'number') {\n          if (_this3.state.pageX !== pageX || _this3.state.pageY !== pageY) {\n            _this3.setState({\n              pageX: pageX,\n              pageY: pageY\n            });\n          }\n        }\n      }.bind(this));\n    }\n  }, {\n    key: \"onResponderGrant\",\n    value: function onResponderGrant(evt, gestureState) {\n      this.props.onTransformStart && this.props.onTransformStart();\n      this.setState({\n        responderGranted: true\n      });\n      this.measureLayout();\n    }\n  }, {\n    key: \"onResponderMove\",\n    value: function onResponderMove(evt, gestureState) {\n      this.cancelAnimation();\n      var dx = gestureState.moveX - gestureState.previousMoveX;\n      var dy = gestureState.moveY - gestureState.previousMoveY;\n\n      if (this.props.enableResistance) {\n        var d = this.applyResistance(dx, dy);\n        dx = d.dx;\n        dy = d.dy;\n      }\n\n      if (!this.props.enableTranslate) {\n        dx = dy = 0;\n      }\n\n      var transform = {};\n\n      if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {\n        var scaleBy = gestureState.pinch / gestureState.previousPinch;\n        var pivotX = gestureState.moveX - this.state.pageX;\n        var pivotY = gestureState.moveY - this.state.pageY;\n        var rect = transformedRect(transformedRect(this.contentRect(), this.currentTransform()), new Transform(scaleBy, dx, dy, {\n          x: pivotX,\n          y: pivotY\n        }));\n        transform = getTransform(this.contentRect(), rect);\n      } else {\n        if (Math.abs(dx) > 2 * Math.abs(dy)) {\n          dy = 0;\n        } else if (Math.abs(dy) > 2 * Math.abs(dx)) {\n          dx = 0;\n        }\n\n        transform.translateX = this.state.translateX + dx / this.state.scale;\n        transform.translateY = this.state.translateY + dy / this.state.scale;\n      }\n\n      this.updateTransform(transform);\n      return true;\n    }\n  }, {\n    key: \"onResponderRelease\",\n    value: function onResponderRelease(evt, gestureState) {\n      var handled = this.props.onTransformGestureReleased && this.props.onTransformGestureReleased({\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      });\n\n      if (handled) {\n        return;\n      }\n\n      if (gestureState.doubleTapUp) {\n        if (!this.props.enableScale) {\n          this.animateBounce();\n          return;\n        }\n\n        var pivotX = 0,\n            pivotY = 0;\n\n        if (gestureState.dx || gestureState.dy) {\n          pivotX = gestureState.moveX - this.state.pageX;\n          pivotY = gestureState.moveY - this.state.pageY;\n        } else {\n          pivotX = gestureState.x0 - this.state.pageX;\n          pivotY = gestureState.y0 - this.state.pageY;\n        }\n\n        this.performDoubleTapUp(pivotX, pivotY);\n      } else {\n        if (this.props.enableTranslate) {\n          this.performFling(gestureState.vx, gestureState.vy);\n        } else {\n          this.animateBounce();\n        }\n      }\n    }\n  }, {\n    key: \"performFling\",\n    value: function performFling(vx, vy) {\n      var startX = 0;\n      var startY = 0;\n      var maxX, minX, maxY, minY;\n      var availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n      if (vx > 0) {\n        minX = 0;\n\n        if (availablePanDistance.left > 0) {\n          maxX = availablePanDistance.left + this.props.maxOverScrollDistance;\n        } else {\n          maxX = 0;\n        }\n      } else {\n        maxX = 0;\n\n        if (availablePanDistance.right > 0) {\n          minX = -availablePanDistance.right - this.props.maxOverScrollDistance;\n        } else {\n          minX = 0;\n        }\n      }\n\n      if (vy > 0) {\n        minY = 0;\n\n        if (availablePanDistance.top > 0) {\n          maxY = availablePanDistance.top + this.props.maxOverScrollDistance;\n        } else {\n          maxY = 0;\n        }\n      } else {\n        maxY = 0;\n\n        if (availablePanDistance.bottom > 0) {\n          minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;\n        } else {\n          minY = 0;\n        }\n      }\n\n      vx *= 1000;\n      vy *= 1000;\n\n      if (Math.abs(vx) > 2 * Math.abs(vy)) {\n        vy = 0;\n      } else if (Math.abs(vy) > 2 * Math.abs(vx)) {\n        vx = 0;\n      }\n\n      this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);\n    }\n  }, {\n    key: \"performDoubleTapUp\",\n    value: function performDoubleTapUp(pivotX, pivotY) {\n      console.log('performDoubleTapUp...pivot=' + pivotX + ', ' + pivotY);\n      var curScale = this.state.scale;\n      var scaleBy;\n\n      if (curScale > (1 + this.props.maxScale) / 2) {\n        scaleBy = 1 / curScale;\n      } else {\n        scaleBy = this.props.maxScale / curScale;\n      }\n\n      var rect = transformedRect(this.transformedContentRect(), new Transform(scaleBy, 0, 0, {\n        x: pivotX,\n        y: pivotY\n      }));\n      rect = transformedRect(rect, new Transform(1, this.viewPortRect().centerX() - pivotX, this.viewPortRect().centerY() - pivotY));\n      rect = alignedRect(rect, this.viewPortRect());\n      this.animate(rect);\n    }\n  }, {\n    key: \"applyResistance\",\n    value: function applyResistance(dx, dy) {\n      var availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n      if (dx > 0 && availablePanDistance.left < 0 || dx < 0 && availablePanDistance.right < 0) {\n        dx /= 3;\n      }\n\n      if (dy > 0 && availablePanDistance.top < 0 || dy < 0 && availablePanDistance.bottom < 0) {\n        dy /= 3;\n      }\n\n      return {\n        dx: dx,\n        dy: dy\n      };\n    }\n  }, {\n    key: \"cancelAnimation\",\n    value: function cancelAnimation() {\n      this.state.animator.stopAnimation();\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(targetRect, durationInMillis) {\n      var _this4 = this;\n\n      var duration = 200;\n\n      if (durationInMillis) {\n        duration = durationInMillis;\n      }\n\n      var fromRect = this.transformedContentRect();\n\n      if (fromRect.equals(targetRect)) {\n        console.log('animate...equal rect, skip animation');\n        return;\n      }\n\n      this.state.animator.removeAllListeners();\n      this.state.animator.setValue(0);\n      this.state.animator.addListener(function (state) {\n        var progress = state.value;\n        var left = fromRect.left + (targetRect.left - fromRect.left) * progress;\n        var right = fromRect.right + (targetRect.right - fromRect.right) * progress;\n        var top = fromRect.top + (targetRect.top - fromRect.top) * progress;\n        var bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;\n        var transform = getTransform(_this4.contentRect(), new Rect(left, top, right, bottom));\n\n        _this4.updateTransform(transform);\n      });\n      Animated.timing(this.state.animator, {\n        toValue: 1,\n        duration: duration,\n        easing: Easing.inOut(Easing.ease)\n      }).start();\n    }\n  }, {\n    key: \"animateBounce\",\n    value: function animateBounce() {\n      var curScale = this.state.scale;\n      var minScale = 1;\n      var maxScale = this.props.maxScale;\n      var scaleBy = 1;\n\n      if (curScale > maxScale) {\n        scaleBy = maxScale / curScale;\n      } else if (curScale < minScale) {\n        scaleBy = minScale / curScale;\n      }\n\n      var rect = transformedRect(this.transformedContentRect(), new Transform(scaleBy, 0, 0, {\n        x: this.viewPortRect().centerX(),\n        y: this.viewPortRect().centerY()\n      }));\n      rect = alignedRect(rect, this.viewPortRect());\n      this.animate(rect);\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform(transform) {\n      this.setState(transform);\n    }\n  }, {\n    key: \"forceUpdateTransform\",\n    value: function forceUpdateTransform(transform) {\n      this.setState(transform);\n    }\n  }, {\n    key: \"getAvailableTranslateSpace\",\n    value: function getAvailableTranslateSpace() {\n      return availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n    }\n  }]);\n\n  return ViewTransformer;\n}(Component);\n\nViewTransformer.Rect = Rect;\nViewTransformer.getTransform = getTransform;\nexport { ViewTransformer as default };\nViewTransformer.propTypes = {\n  enableTransform: PropTypes.bool,\n  enableScale: PropTypes.bool,\n  enableTranslate: PropTypes.bool,\n  maxOverScrollDistance: PropTypes.number,\n  maxScale: PropTypes.number,\n  contentAspectRatio: PropTypes.number,\n  enableResistance: PropTypes.bool,\n  onViewTransformed: PropTypes.func,\n  onTransformGestureReleased: PropTypes.func,\n  onSingleTapConfirmed: PropTypes.func\n};\nViewTransformer.defaultProps = {\n  maxOverScrollDistance: 20,\n  enableScale: true,\n  enableTranslate: true,\n  enableTransform: true,\n  maxScale: 1,\n  enableResistance: false\n};","map":{"version":3,"sources":["/Users/finnbeardmore/Documents/GitHub/ITCrowd/node_modules/react-native-view-transformer/library/transform/ViewTransformer.js"],"names":["React","Component","ReactNative","PropTypes","createResponder","Scroller","Rect","Transform","transformedRect","availableTranslateSpace","fitCenterRect","alignedRect","getTransform","ViewTransformer","props","state","scale","translateX","translateY","animator","Animated","Value","width","height","pageX","pageY","_viewPortRect","cancelAnimation","bind","contentRect","transformedContentRect","animate","scroller","dx","dy","isFinished","animateBounce","updateTransform","set","rect","viewPortRect","copy","contentAspectRatio","currentTransform","gestureResponder","onStartShouldSetResponder","evt","gestureState","onMoveShouldSetResponderCapture","onResponderMove","onResponderGrant","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","onResponderSingleTapConfirmed","onSingleTapConfirmed","prevProps","prevState","onViewTransformed","enableTransform","onLayout","flex","transform","children","e","nativeEvent","layout","setState","measureLayout","handle","findNodeHandle","refs","NativeModules","UIManager","measure","x","y","onTransformStart","responderGranted","moveX","previousMoveX","moveY","previousMoveY","enableResistance","d","applyResistance","enableTranslate","previousPinch","pinch","enableScale","scaleBy","pivotX","pivotY","Math","abs","handled","onTransformGestureReleased","doubleTapUp","x0","y0","performDoubleTapUp","performFling","vx","vy","startX","startY","maxX","minX","maxY","minY","availablePanDistance","left","maxOverScrollDistance","right","top","bottom","fling","console","log","curScale","maxScale","centerX","centerY","stopAnimation","targetRect","durationInMillis","duration","fromRect","equals","removeAllListeners","setValue","addListener","progress","value","timing","toValue","easing","Easing","inOut","ease","start","minScale","propTypes","bool","number","func","defaultProps"],"mappings":"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","sourcesContent":["'use strict';\n\nimport React, { Component } from 'react';\nimport ReactNative, {\n  View,\n  Animated,\n  Easing,\n  NativeModules,\n} from 'react-native';\nimport PropTypes from 'prop-types';\n\nimport { createResponder } from 'react-native-gesture-responder';\nimport Scroller from 'react-native-scroller';\nimport {\n  Rect,\n  Transform,\n  transformedRect,\n  availableTranslateSpace,\n  fitCenterRect,\n  alignedRect,\n  getTransform,\n} from './TransformUtils';\n\nexport default class ViewTransformer extends Component {\n\n  static Rect = Rect;\n  static getTransform = getTransform;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      //transform state\n      scale: 1,\n      translateX: 0,\n      translateY: 0,\n\n      //animation state\n      animator: new Animated.Value(0),\n\n      //layout\n      width: 0,\n      height: 0,\n      pageX: 0,\n      pageY: 0,\n    };\n    this._viewPortRect = new Rect(); //A holder to avoid new too much\n\n    this.cancelAnimation = this.cancelAnimation.bind(this);\n    this.contentRect = this.contentRect.bind(this);\n    this.transformedContentRect = this.transformedContentRect.bind(this);\n    this.animate = this.animate.bind(this);\n\n    this.scroller = new Scroller(true, (dx, dy, scroller) =>{\n      if (dx === 0 && dy === 0 && scroller.isFinished()) {\n        this.animateBounce();\n        return;\n      }\n\n      this.updateTransform({\n        translateX: this.state.translateX + dx / this.state.scale,\n        translateY: this.state.translateY + dy / this.state.scale\n      })\n    });\n  }\n\n  viewPortRect() {\n    this._viewPortRect.set(0, 0, this.state.width, this.state.height);\n    return this._viewPortRect;\n  }\n\n  contentRect() {\n    let rect = this.viewPortRect().copy();\n    if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n      rect = fitCenterRect(this.props.contentAspectRatio, rect);\n    }\n    return rect;\n  }\n\n  transformedContentRect() {\n    let rect = transformedRect(this.viewPortRect(), this.currentTransform());\n    if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n      rect = fitCenterRect(this.props.contentAspectRatio, rect);\n    }\n    return rect;\n  }\n\n  currentTransform() {\n    return new Transform(this.state.scale, this.state.translateX, this.state.translateY);\n  }\n\n  componentWillMount() {\n    this.gestureResponder = createResponder({\n      onStartShouldSetResponder: (evt, gestureState) => true,\n      onMoveShouldSetResponderCapture: (evt, gestureState) => true,\n      //onMoveShouldSetResponder: this.handleMove,\n      onResponderMove: this.onResponderMove.bind(this),\n      onResponderGrant: this.onResponderGrant.bind(this),\n      onResponderRelease: this.onResponderRelease.bind(this),\n      onResponderTerminate: this.onResponderRelease.bind(this),\n      onResponderTerminationRequest: (evt, gestureState) => false, //Do not allow parent view to intercept gesture\n      onResponderSingleTapConfirmed: (evt, gestureState) => {\n        this.props.onSingleTapConfirmed && this.props.onSingleTapConfirmed();\n      }\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.props.onViewTransformed && this.props.onViewTransformed({\n      scale: this.state.scale,\n      translateX: this.state.translateX,\n      translateY: this.state.translateY\n    });\n  }\n\n  componentWillUnmount() {\n    this.cancelAnimation();\n  }\n\n  render() {\n    let gestureResponder = this.gestureResponder;\n    if (!this.props.enableTransform) {\n      gestureResponder = {};\n    }\n\n    return (\n      <View\n        {...this.props}\n        {...gestureResponder}\n        ref={'innerViewRef'}\n        onLayout={this.onLayout.bind(this)}>\n        <View\n          style={{\n            flex: 1,\n            transform: [\n                  {scale: this.state.scale},\n                  {translateX: this.state.translateX},\n                  {translateY: this.state.translateY}\n                ]\n          }}>\n          {this.props.children}\n        </View>\n      </View>\n    );\n  }\n\n  onLayout(e) {\n    const {width, height} = e.nativeEvent.layout;\n    if(width !== this.state.width || height !== this.state.height) {\n      this.setState({width, height});\n    }\n    this.measureLayout();\n\n    this.props.onLayout && this.props.onLayout(e);\n  }\n\n  measureLayout() {\n    let handle = ReactNative.findNodeHandle(this.refs['innerViewRef']);\n    NativeModules.UIManager.measure(handle, ((x, y, width, height, pageX, pageY) => {\n      if(typeof pageX === 'number' && typeof pageY === 'number') { //avoid undefined values on Android devices\n        if(this.state.pageX !== pageX || this.state.pageY !== pageY) {\n          this.setState({\n            pageX: pageX,\n            pageY: pageY\n          });\n        }\n      }\n\n    }).bind(this));\n  }\n\n  onResponderGrant(evt, gestureState) {\n    this.props.onTransformStart && this.props.onTransformStart();\n    this.setState({responderGranted: true});\n    this.measureLayout();\n  }\n\n  onResponderMove(evt, gestureState) {\n    this.cancelAnimation();\n\n    let dx = gestureState.moveX - gestureState.previousMoveX;\n    let dy = gestureState.moveY - gestureState.previousMoveY;\n    if (this.props.enableResistance) {\n      let d = this.applyResistance(dx, dy);\n      dx = d.dx;\n      dy = d.dy;\n    }\n\n    if(!this.props.enableTranslate) {\n      dx = dy = 0;\n    }\n\n    let transform = {};\n    if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {\n      let scaleBy = gestureState.pinch / gestureState.previousPinch;\n      let pivotX = gestureState.moveX - this.state.pageX;\n      let pivotY = gestureState.moveY - this.state.pageY;\n\n\n      let rect = transformedRect(transformedRect(this.contentRect(), this.currentTransform()), new Transform(\n        scaleBy, dx, dy,\n        {\n          x: pivotX,\n          y: pivotY\n        }\n      ));\n      transform = getTransform(this.contentRect(), rect);\n    } else {\n      if (Math.abs(dx) > 2 * Math.abs(dy)) {\n        dy = 0;\n      } else if (Math.abs(dy) > 2 * Math.abs(dx)) {\n        dx = 0;\n      }\n      transform.translateX = this.state.translateX + dx / this.state.scale;\n      transform.translateY = this.state.translateY + dy / this.state.scale;\n    }\n\n    this.updateTransform(transform);\n    return true;\n  }\n\n  onResponderRelease(evt, gestureState) {\n    let handled = this.props.onTransformGestureReleased && this.props.onTransformGestureReleased({\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      });\n    if (handled) {\n      return;\n    }\n\n\n    if (gestureState.doubleTapUp) {\n      if (!this.props.enableScale) {\n        this.animateBounce();\n        return;\n      }\n      let pivotX = 0, pivotY = 0;\n      if (gestureState.dx || gestureState.dy) {\n        pivotX = gestureState.moveX - this.state.pageX;\n        pivotY = gestureState.moveY - this.state.pageY;\n      } else {\n        pivotX = gestureState.x0 - this.state.pageX;\n        pivotY = gestureState.y0 - this.state.pageY;\n      }\n\n      this.performDoubleTapUp(pivotX, pivotY);\n    } else {\n      if(this.props.enableTranslate) {\n        this.performFling(gestureState.vx, gestureState.vy);\n      } else {\n        this.animateBounce();\n      }\n    }\n  }\n\n\n\n\n\n\n  performFling(vx, vy) {\n    let startX = 0;\n    let startY = 0;\n    let maxX, minX, maxY, minY;\n    let availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n    if (vx > 0) {\n      minX = 0;\n      if (availablePanDistance.left > 0) {\n        maxX = availablePanDistance.left + this.props.maxOverScrollDistance;\n      } else {\n        maxX = 0;\n      }\n    } else {\n      maxX = 0;\n      if (availablePanDistance.right > 0) {\n        minX = -availablePanDistance.right - this.props.maxOverScrollDistance;\n      } else {\n        minX = 0;\n      }\n    }\n    if (vy > 0) {\n      minY = 0;\n      if (availablePanDistance.top > 0) {\n        maxY = availablePanDistance.top + this.props.maxOverScrollDistance;\n      } else {\n        maxY = 0;\n      }\n    } else {\n      maxY = 0;\n      if (availablePanDistance.bottom > 0) {\n        minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;\n      } else {\n        minY = 0;\n      }\n    }\n\n    vx *= 1000; //per second\n    vy *= 1000;\n    if (Math.abs(vx) > 2 * Math.abs(vy)) {\n      vy = 0;\n    } else if (Math.abs(vy) > 2 * Math.abs(vx)) {\n      vx = 0;\n    }\n\n    this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);\n  }\n\n  performDoubleTapUp(pivotX, pivotY) {\n    console.log('performDoubleTapUp...pivot=' + pivotX + ', ' + pivotY);\n    let curScale = this.state.scale;\n    let scaleBy;\n    if (curScale > (1 + this.props.maxScale) / 2) {\n      scaleBy = 1 / curScale;\n    } else {\n      scaleBy = this.props.maxScale / curScale;\n    }\n\n    let rect = transformedRect(this.transformedContentRect(), new Transform(\n      scaleBy, 0, 0,\n      {\n        x: pivotX,\n        y: pivotY\n      }\n    ));\n    rect = transformedRect(rect, new Transform(1, this.viewPortRect().centerX() - pivotX, this.viewPortRect().centerY() - pivotY));\n    rect = alignedRect(rect, this.viewPortRect());\n\n    this.animate(rect);\n  }\n\n  applyResistance(dx, dy) {\n    let availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n    if ((dx > 0 && availablePanDistance.left < 0)\n      ||\n      (dx < 0 && availablePanDistance.right < 0)) {\n      dx /= 3;\n    }\n    if ((dy > 0 && availablePanDistance.top < 0)\n      ||\n      (dy < 0 && availablePanDistance.bottom < 0)) {\n      dy /= 3;\n    }\n    return {\n      dx, dy\n    }\n  }\n\n  cancelAnimation() {\n    this.state.animator.stopAnimation();\n  }\n\n  animate(targetRect, durationInMillis) {\n    let duration = 200;\n    if (durationInMillis) {\n      duration = durationInMillis;\n    }\n\n    let fromRect = this.transformedContentRect();\n    if (fromRect.equals(targetRect)) {\n      console.log('animate...equal rect, skip animation');\n      return;\n    }\n\n    this.state.animator.removeAllListeners();\n    this.state.animator.setValue(0);\n    this.state.animator.addListener((state) =>{\n      let progress = state.value;\n\n      let left = fromRect.left + (targetRect.left - fromRect.left) * progress;\n      let right = fromRect.right + (targetRect.right - fromRect.right) * progress;\n      let top = fromRect.top + (targetRect.top - fromRect.top) * progress;\n      let bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;\n\n      let transform = getTransform(this.contentRect(), new Rect(left, top, right, bottom));\n      this.updateTransform(transform);\n    });\n\n    Animated.timing(this.state.animator, {\n      toValue: 1,\n      duration: duration,\n      easing: Easing.inOut(Easing.ease)\n    }).start();\n  }\n\n  animateBounce() {\n    let curScale = this.state.scale;\n    let minScale = 1;\n    let maxScale = this.props.maxScale;\n    let scaleBy = 1;\n    if (curScale > maxScale) {\n      scaleBy = maxScale / curScale;\n    } else if (curScale < minScale) {\n      scaleBy = minScale / curScale;\n    }\n\n    let rect = transformedRect(this.transformedContentRect(), new Transform(\n      scaleBy,\n      0,\n      0,\n      {\n        x: this.viewPortRect().centerX(),\n        y: this.viewPortRect().centerY()\n      }\n    ));\n    rect = alignedRect(rect, this.viewPortRect());\n    this.animate(rect);\n  }\n\n  // Above are private functions. Do not use them if you don't known what you are doing.\n  // ***********************************************************************************\n  // Below are public functions. Feel free to use them.\n\n\n  updateTransform(transform) {\n    this.setState(transform);\n  }\n\n\n  forceUpdateTransform(transform) {\n    this.setState(transform);\n  }\n\n  getAvailableTranslateSpace() {\n    return availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n  }\n}\n\nViewTransformer.propTypes = {\n  /**\n   * Use false to disable transform. Default is true.\n   */\n  enableTransform: PropTypes.bool,\n\n  /**\n   * Use false to disable scaling. Default is true.\n   */\n  enableScale: PropTypes.bool,\n\n  /**\n   * Use false to disable translateX/translateY. Default is true.\n   */\n  enableTranslate: PropTypes.bool,\n\n  /**\n   * Default is 20\n   */\n  maxOverScrollDistance: PropTypes.number,\n\n  maxScale: PropTypes.number,\n  contentAspectRatio: PropTypes.number,\n\n  /**\n   * Use true to enable resistance effect on over pulling. Default is false.\n   */\n  enableResistance: PropTypes.bool,\n\n  onViewTransformed: PropTypes.func,\n\n  onTransformGestureReleased: PropTypes.func,\n\n  onSingleTapConfirmed: PropTypes.func\n};\nViewTransformer.defaultProps = {\n  maxOverScrollDistance: 20,\n  enableScale: true,\n  enableTranslate: true,\n  enableTransform: true,\n  maxScale: 1,\n  enableResistance: false\n};\n"]},"metadata":{},"sourceType":"module"}